---
title: 后端分层架构学习笔记
date: 2025-8-8 23:57:31
tags:
  - 后端架构
categories:
  - 技术分享
description: 后端分层架构学习笔记
---

最近在学习后端分层架构，以下是我的学习笔记。

我发现在学习一个框架时，模仿已有的代码写新的代码这个并不难，但是彻底理解每一层都是干什么的还是比较难。只有在不断练习，不断写很多代码后才能有更深的体会和理解，不然就无法提升一个level，只能做初级工程师。我要不断记录自己的所有疑惑和想法，这样才能不断提高自己的水平，早日成为高级的工程师。

目前我接触的项目是Kratos框架，有非常多层，DTO、DAO、Service、Controller......这些层在Spring boot框架下也是类似的。我感觉分层的作用，就是把后端的工作——给前端提供接口、对数据库进行增删改查进行明确的划分。比如对数据库的操作一层，对http请求一层，对前端数据变成和数据库相关的数据一层，鉴权等中间件一层。这样在出问题的时候，可以及时排查出是哪一层有问题，同时代码的框架也会更清晰，后续的人修改增加都更为简单，提高了代码的可读性和可维护性。

下面对是对各层的介绍

### 1. DAO（Data Access Object）——数据访问层

作用：
专门与数据库打交道，封装所有”对数据库的CRUD操作“。

职责：
- 负责**执行SQL查询** （如查表、插入、更新、删除）
- 屏蔽底层数据库逻辑，使其他层不关心数据库细节
- 一般会对应数据库的”表“

举例：
```go
// dao/user_dao.go
type UserDAO struct {
	db *gorm.DB
}

func NewUserDAO(db *gorm.DB) *UserDAO {
	return &UserDAO{db: db}
}

func (dao *UserDAO) Create(user *User) error {
	return dao.db.Create(user).Error
}

```


### 2. DTO（Data Transfer Object）——数据传输对象层

作用：
用于**请求参数和响应数据的定义与校验**，通常是JSON与结构体的桥梁。

职责：
- 定义前端传来的数据格式
- 定义要返回给前端的数据格式
- 不包含任何逻辑，仅是**数据格式说明**

举例：
```go
//注册请求体DTO
type RegisterRequest struct {
	Username string `json:"username" binding:"required"`
	Password string `json:"password" binding:"required"`
}

// 返回体 DTO
type UserResponse struct {
	ID int `json:"id"`
	Username string `json:"username"`
}
```


### 3. Service（服务层）——业务逻辑层

作用：
处理**业务逻辑**，是整个程序的核心处理器。

职责：
- 组织多个DAO的调用
- 实现核心业务流程（比如“注册账号” = 校验 + 加密密码 + 库存）
- 可以加事务、日志、缓存逻辑等

举例：
```go
// service/user_service.go
type UserService struct {
	userDAO *UserDAO
}

func NewUserService(userDAO *UserDAO) *UserService {
	return &UserService{userDAO: userDAO}
}

func (s *UserService) RegisterUser(req RegisterRequest) (*UserResponse, error) {
	hashedPwd := HashPassword(req.Password)
	user := &User{Username: req.Username, Password: hashedPwd}

	if err := s.userDAO.Create(user); err != nil {
		return nil, err
	}

	return &UserResponse{
		ID:       user.ID,
		Username: user.Username,
	}, nil
}

```

### 4. Controller（控制器层）——接口控制层

作用：
处理HTTP请求，接收前端数据，调用service并返回结果。

职责：
- 接收和校验i请求体（绑定JSON）
- 调用对应Service
- 返回响应给前端

举例：
```go
func (c *UserController) Register(ctx *gin.Context) {
	var req RegisterRequest
	if err := ctx.ShouldBindJSON(&req); err != nil {
		ctx.JSON(400, gin.H{"error": err.Error()})
		return
	}

	resp, err := c.userService.RegisterUser(req)
	if err != nil {
		ctx.JSON(500, gin.H{"error": err.Error()})
		return
	}

	ctx.JSON(200, resp)
}

```


### 5.注册路由层（Router）——接口映射层

作用：
负责将HTTP路径映射到具体的Handler函数（Controller）。

职责：
- 定义接口URL路径
- 指定请求方法（GET、POST等）
- 把接口和Controller绑定起来

举例（Gin框架）：
```go
func RegisterRouter(r *gin.Engine) {
	api := r.Group("/api")
	{
		api.POST("/register", RegisterHandler)
		api.POST("/login", LoginHandler)
	}
}
```


### 各层之间的关系

```csharp
             请求（前端）

                ↓
          [Controller]  接收请求 & 参数绑定
                ↓
          [Service]      业务逻辑 & 调用 DAO
                ↓
            [DAO]         数据库访问
                ↓
             数据库

                ↑
          [DTO] 定义请求与响应的数据结构

```


### 总结

| 层级         | 作用                | 典型关键词                    |
| ---------- | ----------------- | ------------------------ |
| Router     | 注册路径 → Controller | `r.GET`, `r.POST`        |
| Controller | 接收请求 → 调用 Service | `c.ShouldBind`, `c.JSON` |
| Service    | 业务逻辑 → 调用 DAO     | 事务、逻辑判断等                 |
| DAO        | 封装数据库操作           | `db.Create`, `db.Find`   |
| DTO        | 定义请求/响应数据结构       | `json:"xxx"`，校验标签        |

### 分层架构的优点

- **职责清晰：** 每层只负责一类事，便于维护
- **易于测试：** 可以单独测试Service / DAO /Controller
- **利于扩展和重构：** 更换数据库、调整接口、改业务逻辑都很容易
- **解耦：** 前后端、数据库、业务逻辑可以各自修改互不影响


### 一次完整请求的流转顺序：

前端请求 → `路由匹配` → `Controller 参数校验` → `Service 执行业务逻辑` → `DAO 查数据库` → 返回结果


### 总结一句话记住它

>Controller 负责接受请求、Service处理业务逻辑、DAO操作数据库、DTO传输数据、Router注册路由路径。