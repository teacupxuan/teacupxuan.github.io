---
title: 线程池详解
date: 2025-9-26 23:32:31
tags:
  - 后端架构
categories:
  - 技术分享
description: 线程池详解
---

#### 1.  线程池到底创建了什么?

当你在程序里初始化一个线程池时，主要创建了以下几个关键内容：
	**1.** **任务队列**
		- 存放还没被执行的任务
		- 本质就是一个阻塞队列
	**2. 工作线程**
		- 线程池提前创建（或按需创建）一定数量的线程，称为“工作线程”。
		- 这些线程不会立即退出，而是一直存活，等待从队列里取任务。
	**3. 线程池管理器**
		- 负责整体调度，比如：
			- 接收任务
			- 分配任务到线程
			- 动态扩容/缩容线程
			- 超时回收闲置线程

所以：线程池不是“只是一堆线程", 而是 **管理器+线程集合+任务队列** 的组合。

#### 2.  线程池中哪些东西可以复用？

可以复用的部分：
- **线程对象：**
	创建一个线程成本很高（涉及系统调用、栈内存分配、内核调度器注册），如果每次执行任务都新建线程再销毁，开销大。线程池中的工作线程是长期存活的，执行完一个任务后不会销毁，而是继续回到队列里等待下一个任务。
- **上下文环境：**
	每个线程会分配一个**线程栈、寄存器上下文、TLS（Thread Local Storage）** 等。线程池避免了这些反复创建和销毁。

不能复用的部分：
- **任务本身**（Runnable/Callable）：每次提交的任务对象都是新的，执行完就结束。
- **任务数据**：任务运行时使用的数据不会自动保存下来，任务结束就释放。


#### 3. 线程复用的具体流程
假设你调用了 `threadPool.excute(task)`, 流程是这样的：
	1. 提交任务
		任务放进线程池的任务队列。
	2. 工作线程提取任务
		空闲的工作线程会阻塞在队列的`take()`操作上，一旦有新任务，它立刻取出。
	3. 执行任务
		工作线程调用`task.run()`方法，执行具体逻辑。
	4. 任务结束，线程不销毁
		执行完后，线程不会退出，而是再次回到“取任务”的循环，继续等待下一个任务。

这就是“复用”的核心：线程活着，但执行的任务不断切换。

#### 4. 线程池如何调度和管理？
线程池不是死板的，它有一些策略：
- **核心线程数**
	一开始只保留这么多线程
- **最大线程数**
	当任务很多、队列塞不下时，会临时增加线程，直到这个上限。
- **空闲回收**
	当线程闲置超过一定时间，就会被回收销毁，避免浪费资源。
- **拒绝策略**
	如果任务太多，队列满了、线程也到达上限，就会触发拒绝策略（抛异常、丢弃、调用方法执行等）。

  java的线程池里面有4种内置策略：
  1. AbortPolicy（默认）
	  - **做法**：直接抛出`RejectedExecutionException` 异常。
	  - **特点**：强制提醒调用方“任务没执行”，最严格。
	  - **适用场景**：不能丢任务的系统（调用方必须处理异常）。
   2. CallerRunsPolicy
	   - **做法**：由**提交任务的线程**自己来执行这个任务。
	   - **特点**：不会丢任务，但会拖慢提交方的速度，从而间接“限流”。
	   - **适用场景**：允许降低吞吐量来保护系统，比如后台批处理。
   3. DiscardPolicy
	   - **做法**：直接丢弃这个任务，不抛异常。
	   - **特点**：任务“静默消失”，调用方不知道。
	   - **适用场景**：允许丢任务且不在意，比如日志上报、监控采样。
   4. DiscardOldestPolicy
	   - **做法**：丢掉队列中**最旧的任务**，再尝试提交新任务。
	   - **特点**：新任务优先，旧任务可能永远执行不到。
	   - **适用场景**：实时性比完整性更重要的系统，比如缓存刷新。

#### 5. 比喻
把线程池想象成一个 **快餐店**：

- **线程池管理器** → 店长
- **工作线程** → 店员
- **任务队列** → 顾客等待区
- **任务** → 顾客的订单
    
流程是这样的：  
顾客下单（提交任务） → 等待区排队（任务队列） → 店员接单（工作线程取任务） → 做饭（执行任务） → 店员继续待命（线程复用，不会辞职）。

如果顾客爆满（任务太多）：
- 店长可能临时招兼职店员（扩容线程）。
- 如果实在爆满，店长会说“不接单了”（拒绝策略）。

#### 6. 小结

- **线程池创建了：任务队列、工作线程集合、调度管理器。**
- **复用的是：线程本身及其运行环境。**
- **任务不可复用，每次提交一个新任务对象。**
- **复用原理：线程执行完任务不销毁，而是回到循环继续取任务。**
- **管理机制：核心数、最大数、回收时间、拒绝策略。**

#### 7. Go语言没有线程池的原因？

分几个层次来解释：
###### 1. 传统语言为什么需要线程池？

像**java / C++**：
- 创建 / 销毁一个线程开销很大（涉及内核态、栈内存分配、系统调用）。
- 线程数量有限（受操作系统调度和内存限制），太多线程会导致上下文切换成本巨大。

所以要搞“线程池”，提前创建好线程，反复复用，减少开销。

###### 2. Go的设计思路

Go引入了 **goroutine + 调度器 （M:N模型）**：
- **Goroutine**：极轻量的协程，创建成本只有几KB栈空间，不是一个“重量级线程”。
- **Go调度器（GMP模型）**：把成千上万个goroutine自动调度到少量操作系统线程（M）上执行。

> 所以你写的 `go func() {...}` , 底层不是直接起一个OS线程，而是起一个goroutine，由 Go runtime 帮你调度。

这就相当于Go runtime 内部已经帮你实现了“一个大线程池”。

###### 3. 为什么 Go 不需要显式线程池？

- 在 Go 里，goroutine 就是“任务单元”，调度器会自动把它们安排到系统线程上。
- 你要起 1 万个 goroutine 没问题，Go runtime 会自动复用少量 OS 线程。
- 因此你不需要手动管理“线程池”，只需要限制 goroutine 的并发量（比如控制同时运行多少个 worker）。

###### 4. 那么Go里需要“池化”吗?

有，但不是 **线程池**，而是：
1. **连接池**（DB/HTTP 连接池）
2. **对象池**（`sync.Pool`，用来复用对象，减少 GC 压力）
3. **Worker Pool**（goroutine 池，本质是限制同时运行的 goroutine 数量，避免无限制创建）

###### 5. 总结

- Go 里没有“线程池”，因为 goroutine 本身就足够轻量，runtime 已经在底层做了调度和线程复用。
- 你通常只需要控制“并发数”，用 channel + worker pool 实现就行。
- 如果是对象/资源的复用，Go 提供 `sync.Pool`、连接池等机制。
