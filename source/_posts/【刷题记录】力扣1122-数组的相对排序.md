---
title: 【刷题记录】力扣1122-数组的相对排序
date: 2025-8-11 23:17:31
tags:
  - 刷题
categories:
  - 算法学习
description: 【刷题记录】力扣1122-数组的相对排序，桶排序
---

### 题目：
给你两个数组，`arr1` 和 `arr2`，`arr2` 中的元素各不相同，`arr2` 中的每个元素都出现在 `arr1` 中。
对 `arr1` 中的元素进行排序，使 `arr1` 中项的相对顺序和 `arr2` 中的相对顺序相同。未在 `arr2` 中出现过的元素需要按照升序放在 `arr1` 的末尾。

### 示例1：
**输入：** arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]
**输出：**[2,2,2,1,4,3,3,9,6,7,19]

### 示例2：
**输入：** arr1 = [28,6,22,8,44,17], arr2 = [22,28,8,6]
**输出：**[22,28,8,6,17,44]

### 提示：
- `1 <= arr1.length, arr2.length <= 1000`
- `0 <= arr1[i], arr2[i] <= 1000`
- `arr2` 中的元素 `arr2[i]`  **各不相同** 
- `arr2` 中的每个元素 `arr2[i]` 都出现在 `arr1` 中

### 题解：

```java
class Solution {
	public int[] relativeSortArray(int[] arr1, int[] arr2){
		// 找出 arr1 中的最大值upper，用于后面开桶数组
		int upper = 0;
		for(int x : arr1){
			upper = Math.max(upper. x);
		}

		// 创建一个频次数组frequency,长度为最大值+1
		// frequency[i] 表示数字i在arr1中出现的次数
		int[] frequency = new int[upper + 1];
		for(int x : arr1) {
			++frequency[x];
		}

		// 创建结果数组ans,用来存最终的排序结果
		int[] ans = new int[arr1.length];
		int index = 0; // 指向ans的下一个待填充位置

		// 先按照 arr2 的顺序填充结果
		// arr2 中的每个数在 arr1 中的出现次数，依次放入ans
		for(int x : arr2) {
			for(int i = 0; i < frequency[x]; ++i) {
				ans[index++] = x;
			}
			frequency[x] = 0; // 已经放到ans里了，把频次清零
		}

		// 再处理 arr2 之外的数字
		// 这些数字需要按升序排序（frequency 数组天然是升序遍历）
		for(int x = 0;x <= upper; ++x) {
			for(int i = 0; i < frequency[x] ; i++) {
				ans[index++] = x;
			}
		}

		// 返回最终结果
		return ans;
	
	}
}
```


这个解法的思路其实就是**桶排序（Counting Sort）+ 按 arr2 的顺序优先填充**：

1. 统计 `arr1` 中每个数字的出现次数。
    
2. 按 `arr2` 给定的顺序把对应数字放到答案里。
    
3. 剩下没出现过在 `arr2` 里的数字按自然升序补到答案末尾。
