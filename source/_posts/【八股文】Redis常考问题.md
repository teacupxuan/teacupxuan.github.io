---
title: 【八股文】Redis常考问题
date: 2025-9-15 23:32:31    
tags:
  - Redis
categories:
  - 面试准备    
description: 【八股文】Redis常考问题
---

#### 1. Redis常见数据结构及应用场景?

- String：最常用，缓存对象、计数器（比如点赞数、浏览量）；
- Hash：存储对象，适合保存用户信息；
- List：消息队列，支持阻塞操作；
- Set：去重，抽奖系统、好友推荐；
- ZSet：有序集合，排行榜、延迟队列。

###### 项目结合：
我在项目中主要用过**String**存储用户弹窗标记，避免重复查询数据库；
**ZSet**在赛季排名系统中也非常典型，可以用来存储用户分数和排名。

#### 2. Redis 常见数据结构的底层实现?

**String**
- 底层是**SDS（简单动态字符串 simple dynamic string）**,比C语言字符串更安全高效率：
	- 额外保存length，O(1)获取长度；
	- 杜绝缓冲区溢出，扩容时按倍数扩展；
	- 预留空间，减少频繁realloc。
- **项目应用：** 存储用户是否弹窗过的标记，用 `SET key value EX 3600` ，避免重复查询数据库。

**Hash**
- 底层有两种结构：
	1. ziplist（压缩列表，小数据量时用，节省内存）；
	2. hashtable（大数据量时用，O(1)查找）。
- **项目应用：** 存储用户信息，如 `user:1001 -> {name: "张三", age: 20}`。

**List**
- 底层是 **双向链表+压缩列表**。
- **项目应用：** 在订餐项目中，可以用List实现一个简单的订单队列。

**Set**
- 底层是 **哈希表** 或 **整数数组**（intset）。
- **项目应用：** 用户去重、存储用户参与的战队成员ID。

**Zset（有序集合）**
- 底层是**跳表 + 哈希表**。
- **项目应用：** 在赛季排名系统里，最常用的数据结构就是ZSet，用`ZADD` 存储用户分数，`ZRANGE` 获取排名。

#### 3. Redis为什么快?

- 基于**内存存储**，访问速度快；
- 使用**单线程模型 + IO多路复用**，避免多线程上下文切换；
- 高效的数据结构（哈希表、跳表）；
- 使用**异步持久化**（RDB、AOF），减少阻塞。

**简洁表达：** Redis快的本质是「**内存操作 + 高效数据结构 + 单线程避免锁竞争**」。

#### 4. Redis缓存雪崩、穿透、击穿的区别和解决方案?

**缓存雪崩：** 大量缓存同一时间失效，请求全部打到数据库。
- 解决：设置不同的过期时间 + 热点数据永不过期 + 限流。

**缓存穿透：** 查询不存在的数据，每次都打到数据库。
- 解决：布隆过滤器、缓存空对象。

**缓存击穿：** 热点key在失效瞬间，大量并发请求涌入数据库。
- 解决：互斥锁（分布式锁）、逻辑过期 + 异步刷新。

###### 项目结合：
我在赛季排名（查询某个战队上个赛季的排名信息）优化时就遇到类似击穿的问题，解决方案是 **预计算 + 多层缓存 + 降级机制** ，避免大规模请求落到数据库。

#### 5. 缓存雪崩、穿透、击穿解决方案深入解释

**缓存穿透 —— 布隆过滤器原理**
- 布隆过滤器本质是一个 **位数组 + k个哈希函数**；
- 插入元素时，用k个哈希函数算出位置，把对应位标记为1；
- 查询时，再算一次哈希函数，看这些位置是否都为1，如果有一个不是1，说明元素一定不存在。
- **缺点：** 可能误判存在，但不会误判不存在。
- **项目应用：** 对于请求的用户ID，如果布隆过滤器判断不存在，就直接返回，不访问数据库。

**缓存击穿 —— 互斥锁实现**
- 常见实现方式：
	- 请求缓存时，如果发现key过期了，用 `SETNX lockKey` 获取锁；
	- 获取锁成功的线程去查询数据库，并回填缓存；
	- 其他线程等待锁释放后再去读取缓存。
- **项目应用：** 在赛季排名的热点数据中，我设计了「预计算 + 多层缓存」，相当于在缓存击穿之前就做好了兜底；如果真的击穿了，才会触发互斥锁，避免大规模并发打到数据库。

#### 6. Redis持久化方式有哪些？区别是什么？

- **RDB（快照）：** 定期保存内存快照到磁盘；优点是恢复快，缺点是可能丢失最后一次快照之后的数据。
- **AOF（日志）：** 记录每次写操作；优点是更安全，丢失数据少；缺点是文件体积大，恢复速度慢。
- **混合持久化：** Redis 4.0 引入后，结合RDB + AOF。

面试官可能追问：
- 线上更推荐**AOF + RDB 混合模式**，平衡性能与可靠性。

#### 7. Redis持久化深入问题

**RDB快照**
- Redis 会 fork 一个子进程，把内存数据写入临时文件，最后替换掉原有的RDB文件。
- **问题：RDB文件太多了怎么办?**
	- Redis 默认会根据配置生成多个快照文件，比如 save 900 1 (15分钟有一次修改就快照一次)；
	- 如果太频繁，可能造成IO压力。
	- 解决：合理配置快照频率，或者结合AOF使用混合持久化。

**AOF日志**
- 存储位置：`appendonly.aof` , 默认在Redis工作目录下；
- **问题：AOF太大怎么办?**
	- Redis 会定期做 **AOF重写（rewrite）：** 开启一个新文件，只写当前数据库状态所需的最小命令集，减少文件大小；
	- 可以配置 `auto-aof-rewrite-percentage` 和 `auto-aof-rewrite-min-size` 来控制触发重写的条件。

#### 8. Redis如何保证高可用?

- **主从复制：** 一主多从，读写分离；
- **哨兵模式：** 监控主节点故障，自动切换；
- **集群模式：** 数据分片，水平扩展，支持大规模存储。

回答建议：
可以说在公司项目里主要使用的是单节点 + 高可用配置，连接池调优来避免连接瓶颈；但了解集群和哨兵的原理。

#### 9. Redis 高可用：哨兵模式

**哨兵的核心功能：**
1. 监控（Monitoring）：周期性发送 PING 检测主节点和从节点是否存活；
2. 通知（Notification）：当发现节点宕机时，会通知其他哨兵和客户端；
3. 自动故障转移（Automatic failover）：当主节点宕机时，哨兵会从从节点中选举一个作为新节点，并让其他从节点去复制它；
4. 服务发现：客户端通过哨兵获取新的主节点地址。

**主节点故障检测机制：**
- 哨兵通过 **PING** 判断是否超时，如果大多数哨兵（quorum）认为主节点不可达，则触发failover。

**自动切换流程：**
1. 选举一个哨兵为leader；（怎么选?）
2. leader哨兵选择一个延迟最小的从节点提升为新主节点；
3. 通知其他从节点去复制新的主节点；
4. 客户端更新连接信息，继续访问。

#### 10.周期性发送 PING 检测主节点和从节点是否存活；谁定期发送？

- **Redis Sentinel（哨兵）节点**会定期向主节点和从节点发送 `PING` 命令（默认1秒1次）。
- 具体机制：
	- **主观下线：** 如果某个哨兵在一定时间 ()
	- **客观下线：** 多个哨兵进行通信，如果超过一定数量的哨兵都认为主节点下线，才会进入客观下线状态，并触发主从切换流程。
- **回答要点：** 是哨兵主动发PING，不是主节点自己汇报。

#### 11.选举一个哨兵为leader，怎么选的?

- **哨兵 Leader 选举过程：**
	1. 某个主节点被判定为客观下线后，每个哨兵会尝试成为Leader，并向其他哨兵发送投票请求。
	2. 投票过程采用类似 **Raft 算法** 的思路：一个哨兵一轮中只能投一票，投给先请求的候选者。
	3. 如果某个哨兵获得了超过半数的投票（即quorum），它就成为Leader，负责执行主从切换。
- **重点：** 选举过程是去中心化的，保证高可用，避免脑裂。


#### 12. 你提到 Redis 连接池调优，具体是怎么做的？

**标准回答：**
在赛季系统的高并发场景中，Redis曾经出现过 **连接数不足** 的问题。

我的解决步骤是：
	1. 先确认缓存命中率，排除了缓存穿透的问题；（如何确认的？）
	2. 定位瓶颈在 **连接池默认配置过小**；
	3. 调优方案：
		- 调大 `pool_size` , 提升并发连接能力；
		- 设置 `min_idle_conns` , 预热连接，减少首次延迟；
		- 配置 `max_conn_age` , 避免连接长时间占用导致内存浪费；
		- 调整 `idle_check_frequency` , 及时清理坏连接。
	4. 优化效果：请求吞吐量显著提升，系统稳定性提高。

**加分点**：这种回答很能体现你有实际排查 + 优化经验，不是只会背八股。

#### 13. Redis为什么单线程的？能利用多核吗？

**回答要点：**
- Redis的核心操作是内存IO，本身很快，不需要多线程；
- 单线程避免了锁竞争问题，简化实现；
- 可以利用多核：开多个Redis实例，或者用Redis 6 引入的多线程IO。

#### 14. 如果Redis挂了，系统会怎么样？你们项目是怎么处理的？

**标准回答：**
如果Redis挂了，可能导致大量请求直接打到数据库，造成雪崩。
我在项目里设计了**降级机制**：
- 优先走缓存；
- 缓存失效时查数据库；
- 如果数据库也压力过大，就走 **实时计算 + 限流** ，保证系统至少能提供核心功能而不是完全宕机。

#### 15. 如果 Redis 挂掉，项目怎么保证稳定？

**标准回答：**
- 第一层：用 **多层缓存**（本地缓存 + Redis缓存），即使Redis瞬时挂掉，也有本地缓存兜底；（怎么实现本地缓存的？）
- 第二层：设计 **降级机制**，缓存失效时优先走数据库，数据库不行时走实时计算；
- 第三层：通过限流和熔断，保证核心功能可用。（具体怎么做限流和熔断？怎么考量的？）

#### 16. 本地缓存怎么实现？

- **实现方式：**
	- 可以用 **Caffeine / Guava Cache** 这种Java内存缓存库。
	- 核心思路：
		- 查询数据时，先查本地缓存 → 查不到再查Redis → 查不到再查数据库。
		- 本地缓存通常设置 较短的TTL（几十秒 ~ 几分钟），保证热数据快速命中。
	- **在项目里的应用：** 比如赛季配置、常用字典表、系统公告等，这类数据不会频繁变动，放在本地缓存能极大减轻Redis压力。
- **回答要点：** 本地缓存作为第一层兜底，避免 Redis 挂掉时所有请求瞬间打到数据库。

#### 17. 限流和熔断怎么做？怎么考量的？

##### 限流
- **常见算法：**
	- **令牌桶**（Token Bucket）：系统按固定速率往桶里放令牌，请求必须拿到令牌才能通过，保证平滑限流。
	- **漏桶**（Leaky Bucket）：请求以固定速率流出，突发流量会排队或被丢弃。
- **在项目中实现：**
	- 用 Redis 的 `incr + expire` 实现固定窗口限流，例如某接口限制 100 QPS。
	- 或者用 Guava 的 `RateLimiter` ，在本地就能限流。

##### 熔断
- **原理：** 当某个服务或下游接口持续失败率过高时，
- **实现方式：**
	- 可以用 **Resilience4j / Sentinel** 这样的中间件。
	- 设置阈值：比如连续 50% 请求失败，就熔断10秒，期间直接返回 fallback。
- **在项目里的考量：**
	- 赛季排名这种核心功能 → 必须限流保证Redis和数据库不会被压垮。
	- 非核心功能（比如个性化推荐）→ 可以熔断，用户体验稍微降低但不影响主流程。
